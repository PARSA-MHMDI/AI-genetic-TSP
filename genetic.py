# -*- coding: utf-8 -*-
"""Genetic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WXUBN4LHZfloLF_J8tlNp_t1_bY8IDYP

# Genetic Algorithm

## Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import random
import math
import numpy as np
from copy import deepcopy
from copy import copy
import sys
import numpy
numpy.set_printoptions(threshold=sys.maxsize)
import random
import matplotlib.pyplot as plt

# %matplotlib inline

"""## Load Data"""

with open('/content/drive/MyDrive/Colab Notebooks/AI Class Project 1/qa194.tsp') as f:
    file = f.read().split("\n")
    coords = []
    for i in file:
        a , b, c = i.split()
        b = float(b)
        c = float(c)
        coords.append((b,c))
print(coords)

print(type(coords[0][0]))

for i in range(len(coords)):
  plt.plot(coords[i][1], coords[i][0], 'o', color='black');

"""### distance"""

def distance(coord1 , coord2):
  dis = np.sqrt(np.square(coord1[0]-coord2[0]) + np.square(coord1[1]-coord2[1]))
  return dis
distance(coords[0], coords[1])

"""### Make matrix of distance:"""

def tsp_matrix(coords):
  tsp = []
  row = []
  for i in range(len(coords)):
    row.clear()
    for j in range(len(coords)):
      row.append(distance(coords[i] ,coords[j]))
    r = copy(row)
    tsp.append(r)
  return tsp

"""### Make population"""

def make_population(tsp, num):
  """
  This function makes populations, input: tsp is list of roads , num is number of population we want
  """
  cities = list(range(len(tsp)))
  solution = []

  for i in range(len(tsp)):
    random_city = cities[random.randint(0,len(cities)-1)]
    solution.append(random_city)
    cities.remove(random_city)

  neighbors = []
  for i in range(len(solution)): #This for loop will make new list from solution by changing element positions
    for j in range(i+1,len(solution)):
      a = solution.copy()
      a[i] = solution[j]
      a[j] = solution[i]
      neighbors.append(a)

  return neighbors[:num]

#Test
tsp = tsp_matrix(coords)
n = make_population(tsp, 5)
print(len(n),np.array(n))

"""### Cost Function - Route lenght"""

def cost(tsp, solution):
  """
  Funciton input is tsp and solution which tsp is matrix of distance between cites and solution is list of cites

  The output is length of solution from firt city to the goal (cost)
  """
  length = 0.0
  for q in range(len(solution)):
    length += tsp[solution[q-1]][solution[q]]
  return length

#test
n = make_population(tsp, 5)
tsp = tsp_matrix(coords)
for i in n:
  print(f"solution : {i} whit cost of = {cost(tsp, i)}")

"""### top_costs"""

def top_costs(tsp,population,n):
  """
  inputs : 
  tsp:,atrix of distance
  population :list of splutions = [[road1],[road2],....]
  n : is a intiger number and we use that to show n top costs

  output: 

  population_and_cost[:n] : is a list of list of roads(solution) and thire cost 
                            which have been sorted by thir costs

  exp: population_and_cost[:n] = [[[solution0],solution0_cost],[[solution1],solution1_cost] , ... ]

  """
  population_and_cost = []
  for i in population:
    population_and_cost.append([i,cost(tsp,i)])
  population_and_cost.sort(key=lambda x: x[1]) # This line of cods sorts population_and_cost by cost element

  return population_and_cost[:n]

#test funciton above
population = make_population(tsp, 5)
tsp = tsp_matrix(coords)
for i in population:
  print(f"solution : {i} whit cost of = {cost(tsp, i)}")

tops = top_costs(tsp,population,2)

for i in tops:
  print(f"best costs : {i}")

"""### cross_over"""

def cross_over(tsp,top_population, prob=1):
  """
  inputs:
  tsp: matrix of distance
  top_population: list of list of roads and thire costs: [[[road0],cost0],[[road1],cost1],....]

  output:
  new_genration: list of list of roads and thire costs: [[[road0],cost0],[[road1],cost1],....]

  This function makes new road(genration) by swape n elemet of each list
  """
  road_paths = []
  for i in top_population:# In this line of code we collectiong road_paths from top_population
    road_paths.append(i[0])
  
  new_genration = []

  for i in range(1,len(road_paths)):
    if random.random() < prob:  
      p1,p2 = deepcopy(road_paths[i-1]),deepcopy(road_paths[i])
      point = random.randint(1,len(p1)-2)
      
      for j in range(point,len(p1)):
          p1[j],p2[j] = p2[j],p1[j]
      new_genration.append([p1,cost(tsp,p1)])
      new_genration.append([p2,cost(tsp,p2)])
    else:
      new_genration.append(top_population[i-1])

  return new_genration

#test funciton above
population = make_population(tsp, 100000)
tsp = tsp_matrix(coords)

tops = top_costs(tsp,population,5)

for i in tops:
  print(f"best costs : {i}")

new_genration = cross_over(tsp,tops,1)

for j in new_genration:
  print(f"new_genration : {j}")

"""### Mutation"""

def mutation(tsp:"Matrix of distance",cross_over:"The cross overed popultaion" 
             , prob:"probiliy to change a element" = 0.05) -> "[[[road0],cost0],[[road1],cost1],....]":
  """
  inputs:
  tsp: matrix of distance
  top_population: list of list of roads and thire costs: [[[road0],cost0],[[road1],cost1],....]

  output:
  new_genration: list of list of roads and thire costs: [[[road0],cost0],[[road1],cost1],....]

  This function makes new road(genration) by swape n elemet of each list
  """
  road_paths = []
  for i in cross_over:# In this line of code we collectiong road_paths from top_population
    road_paths.append(i[0])

  road_paths_copy = deepcopy(road_paths)

  for j in road_paths:
    for k in range(len(j)):
      if random.random() < prob:
        j[k] = (len(j)-1) - j[k]
  

  new_genration = road_paths

  new_genration_with_cost = []

  for m in new_genration:
    new_genration_with_cost.append([m,cost(tsp,m)])
    
  return new_genration_with_cost

#test funciton above
population = make_population(tsp, 100000)
tsp = tsp_matrix(coords)

tops = top_costs(tsp,population,5)

#for i in tops:
  #print(f"best costs : {i}")

cross_over_population = cross_over(tsp,tops,1)

#for j in cross_over_population:
 #print(f"cross over : {j}")

new_genration = mutation(tsp, cross_over_population, 0.1)

print(len(new_genration))
for k in new_genration:
  print(f"new_genration: {k}")

"""### Genetic"""

def genetic(tsp, ittiration):
  cost_value = []

  population = make_population(tsp, 1000)# making a random population
  top_population = top_costs(tsp,population, 200) # This line of code chooses top 5 lowest cost soultions fromat = [[[solutin0],cost0],[[solutin1],cost1],...]
  
  for i in range(ittiration):
    print(f"ittiration : {i}")
    cross_over_population = cross_over(tsp,top_population,0.085)
    new_genration = mutation(tsp,cross_over_population,0.001)

    new_genration.sort(key=lambda x: x[1])
    cost_value.append(new_genration[0][1])

    top_population =  new_genration
  
  best_cost = new_genration[0][1]

  return best_cost,cost_value

iteration = 100

tsp = tsp_matrix(coords)

best_cost,cost_value = genetic(tsp, iteration)

print(best_cost)

r = []
for i  in range(iteration):
  r.append(i)

plt.plot(r, cost_value, '-o', color='blue');